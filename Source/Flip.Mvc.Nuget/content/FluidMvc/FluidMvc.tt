<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ 
	assembly name="EnvDTE" #><#@ 
	assembly name="EnvDTE80" #><#@
	import namespace="System.IO" #><#@
	import namespace="System.Collections.Generic" #><#@
	import namespace="Microsoft.VisualStudio.TextTemplating" #><#@
	import namespace="EnvDTE" #><#@
	import namespace="EnvDTE80" #><#@
	include file="Manager.ttinclude" #><#
	//System.Diagnostics.Debugger.Launch();
	//System.Diagnostics.Debugger.Break();
#><#
	var manager = Manager.Create(Host, GenerationEnvironment); 
	manager.StartHeader();
#>// <auto-generated />
using System;
using Flip.Web.Routing;

<#
	manager.EndBlock();

	manager.KeepGeneratedFile("Manager.ttinclude");

	var mvcInformation = GetMvcInformation();

	WriteViewFileHeader();
	PushIndent("\t");

	//Views
	WriteViewsRecursively(mvcInformation.DefaultArea.ViewFolder, Settings.GeneratedNamespace);
	foreach(var area in mvcInformation.Areas)
	{
		WriteViewsRecursively(area.ViewFolder, GetNamespace(Settings.GeneratedNamespace, area.Name));
	}
	foreach(var area in mvcInformation.PortableAreas)
	{
		WriteViewsRecursively(area.ViewFolder, GetNamespace(Settings.GeneratedNamespace, area.Name));
	}

	PopIndent();
	WriteLine("}");
	
	//Controllers
	foreach(var controller in mvcInformation.DefaultArea.Controllers)
    {
		WriteController(manager, controller);
    }
	foreach(var area in mvcInformation.Areas)
    {
		foreach(var controller in area.Controllers)
        {
			WriteController(manager, controller);
        }
    }
	foreach(var area in mvcInformation.PortableAreas)
    {
		foreach(var controller in area.Controllers)
        {
			WriteController(manager, controller);
        }
    }

	manager.StartFooter();
	manager.EndBlock();
	manager.Process(true);

#><#+
void WriteController(Manager manager, ControllerInformation controller)
{
	//TODO Enable this later
	//if (!controller.NeedsGeneration) 
	//{
	//	manager.KeepGeneratedFile(controller.FileName);
	//	return;
    //}
	manager.StartNewFile(controller.FileName);
	#>namespace <#= controller.Namespace #>
{
<#+ PushIndent("\t"); #>
public static class <#= controller.ClassName #>
{
<#+
	PushIndent("\t");
	foreach(var action in controller.Actions)
    {
		WriteAction(controller, action);
    }
	PopIndent();
#>
}
<#+ PopIndent(); #>
}<#+
	manager.EndBlock();
}
void WriteAction(ControllerInformation controller, ActionMethodInformation action)
{
	#>public static class <#= action.Name #>
{
<#+ PushIndent("\t"); #>
public const string Name = "<#= action.Name #>";
<#+
	WriteMapFunction(controller, action);
	WriteRouteUrlMethod(action);
	WriteJavascriptRouteBuilderMethod(action);
	PopIndent();
#>
}
<#+
}
void WriteMapFunction(ControllerInformation controller, ActionMethodInformation action)
{
#>
public static RouteBuilder Map()
{
	return new RouteBuilder
	{
		ControllerName = "<#= controller.ClassName #>",
		ActionName = "<#= action.ActionNameExpression #>",
		RouteName = "<#= action.RouteName #>",
	};
}
<#+
}
void WriteRouteUrlMethod(ActionMethodInformation action)
{
}
void WriteJavascriptRouteBuilderMethod(ActionMethodInformation action)
{
}
void WriteViewFileHeader()
{
#>namespace <#= Settings.GeneratedNamespace #>
{
<#+
}
void WriteViewFolder(ViewFolderInformation folder)
{
#>public static class <#= folder.ClassName #>
{
<#+
}
void WriteView(ViewInformation view)
{
#>public const string <#= view.ClassName #> = "<#= view.FileName #>";
<#+
}
void WriteViewsRecursively(ViewFolderInformation folder, string ns)
{
	WriteViewFolder(folder);
	PushIndent("\t");
	foreach(var view in folder.Views)
    {
		WriteView(view);
	}
	foreach(var subFolder in folder.Folders)
    {
		WriteViewsRecursively(subFolder, ns);
	}
	PopIndent();
	WriteLine("}");
}
static Microsoft.CSharp.CSharpCodeProvider CodeProvider = new Microsoft.CSharp.CSharpCodeProvider();
static string TemplateFolderPath;

public static class Settings
{
	public static string GeneratedNamespace = "Routes";
	public static string AreasName = "Areas";
	public static string ControllersFolderName = "Controllers";
	public static string ViewsFolderName = "Views";
	public static List<string> PortableAreaNames = new List<string>() { };
	public static HashSet<string> ViewExtensions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
		".cshtml"
    };
}

MvcInformation GetMvcInformation()
{
	TemplateFolderPath = Path.GetDirectoryName(Host.TemplateFile);

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;

	EnvDTE.DTE dte = null;
    if (serviceProvider != null)
    {
        dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
    }

    if (dte == null)
    {
        throw new Exception("Can only execute through the Visual Studio host");
    }

    var project = GetProject(dte, Host);

    if (project == null)
    {
        Error("Could not find the VS Project containing the T4 file.");
        return null;
    }

    return ParseProject(project);
}
static MvcInformation ParseProject(Project project)
{
	var mvc = new MvcInformation();

    mvc.DefaultArea = ParseArea(project.ProjectItems, null);

    ProjectItem areaProjectItem = GetProjectItem(project, Settings.AreasName);
    
    if (areaProjectItem != null)
    {
        foreach (ProjectItem item in areaProjectItem.ProjectItems)
        {
            if (IsFolder(item))
            {
                mvc.Areas.Add(ParseArea(item.ProjectItems, item.Name));
            }
        }
    }

    foreach (string portableAreaName in Settings.PortableAreaNames)
    {
        ProjectItem portableAreaProjectItem = GetProjectItem(project, portableAreaName);

        if (portableAreaProjectItem == null)
        {
            continue;
        }

        if (IsFolder(portableAreaProjectItem))
        {
            mvc.PortableAreas.Add(ParseArea(portableAreaProjectItem.ProjectItems, portableAreaProjectItem.Name));
        }
    }
	return mvc;
}
static AreaInformation ParseArea(ProjectItems areaFolderItems, string name)
{
	var area = new AreaInformation() { Name = name };
    ParseAreaControllers(areaFolderItems, area);
    ParseAreaViews(areaFolderItems, area);
	return area;
}
static void ParseAreaControllers(ProjectItems areaFolderItems, AreaInformation area)
{
    ProjectItem controllerProjectItem = GetProjectItem(areaFolderItems, Settings.ControllersFolderName);
    if (controllerProjectItem == null)
    {
        return;
    }
    ParseControllersRecursive(controllerProjectItem, area);
}
static void ParseControllersRecursive(ProjectItem projectItem, AreaInformation area)
{
	// Recurse into all the sub-items (both files and folder can have some - e.g. .tt files)
	foreach (ProjectItem item in projectItem.ProjectItems)
	{
		ParseControllersRecursive(item, area);
	}

    if (projectItem.FileCodeModel != null)
    {
        DateTime controllerLastWriteTime = File.GetLastWriteTime(projectItem.get_FileNames(0));
        foreach (var type in projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>())
        {
			ControllerInformation controller;
			if(TryParseController(area.Name, type, controllerLastWriteTime, out controller))
			{
				area.Controllers.Add(controller);
			}
        }
        // Process all the elements that are namespaces
        foreach (var ns in projectItem.FileCodeModel.CodeElements.OfType<EnvDTE.CodeNamespace>())
        {
            foreach (var type in ns.Members.OfType<CodeClass2>())
            {
				ControllerInformation controller;
				if(TryParseController(area.Name, type, controllerLastWriteTime, out controller))
                {
					area.Controllers.Add(controller);
                }
            }
        }
    }
}
static bool TryParseController(string areaName, CodeClass2 type, DateTime lastWriteTime, out ControllerInformation controller)
{
    if (!IsController(type) || type.IsGeneric || type.IsAbstract)
    {
		controller = null;
        return false;
    }

	string fileName = GetFileName(areaName, type.Name + ".generated.cs");
    controller = new ControllerInformation
    {
        Namespace = GetControllerNamespaceFromType(type),
        ClassName = GetControllerClassNameFromType(type),
		FileName = fileName,
		FilePath = GetPathRelativeToTemplate(fileName)
    };

    DateTime lastGenerationTime = File.GetLastWriteTime(controller.FilePath);
	controller.NeedsGeneration = lastGenerationTime < lastWriteTime;
	controller.Actions.AddRange(ParseActionMethods(areaName, controller.ClassName, type));
	return true;
}
static IEnumerable<ActionMethodInformation> ParseActionMethods(string areaName, string controllerName, CodeClass2 controllerType)
{
	var actions = new List<ActionMethodInformation>();
	bool isAsyncController = IsAsyncController(controllerType);

	for (CodeClass2 type = controllerType; type != null && type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2)type.Bases.Item(1))
    {
		foreach (CodeFunction2 method in GetMethods(type, isAsyncController))
        {
			string name = isAsyncController && method.Name.EndsWith("Async", StringComparison.OrdinalIgnoreCase) ? 
					method.Name.Remove(method.Name.Length - 5) :
					method.Name;

			var action = new ActionMethodInformation
            {
				Name = name,
				RouteName = GetRouteName(areaName, controllerName, name),
				ActionNameExpression = GetAttributeValueOrDefault(method.Attributes, "System.Web.Mvc.ActionNameAttribute", name),
            };
			action.Parameters.AddRange(ParseParameters(method));
			actions.Add(action);
       }
    }
	return actions;
}
static IEnumerable<ParameterInformation> ParseParameters(CodeFunction2 method)
{
	var parameters = new List<ParameterInformation>();

	foreach (var codeParameter in method.Parameters.OfType<CodeParameter2>())
    {
		var parameter = new ParameterInformation
        {
			Name = codeParameter.Name,
			Type = codeParameter.Type.AsString,
			Optional = codeParameter.ParameterKind == vsCMParameterKind.vsCMParameterKindOptional,
			DefaultValue = codeParameter.DefaultValue,
			// Note: if the param name starts with @ (e.g. to escape a keyword), we need to trim that
			RouteNameExpression = "\"" + codeParameter.Name.TrimStart('@') + "\""
        };

		// If there is a [Bind(Prefix = "someName")] attribute, use it
		if (codeParameter.InfoLocation != vsCMInfoLocation.vsCMInfoLocationExternal)
        {
			var attribute = GetFirstAttribute(codeParameter.Attributes, "System.Web.Mvc.BindAttribute");
            if (attribute != null)
            {
                var prefix = attribute.Arguments.OfType<EnvDTE80.CodeAttributeArgument>().FirstOrDefault(a => a.Name == "Prefix");
                if (prefix != null)
                {
                    parameter.RouteNameExpression = prefix.Value;
                }
            }
        }
    }
	return parameters;
}
static void ParseAreaViews(ProjectItems areaFolderItems, AreaInformation area)
{
    ProjectItem viewsProjectItem = GetProjectItem(areaFolderItems, Settings.ViewsFolderName);
    if (viewsProjectItem == null)
    {
        return;
    }
	area.ViewFolder.Name = Path.GetFileName(viewsProjectItem.Name);
    ParseViewsRecursive(viewsProjectItem.ProjectItems, area.ViewFolder);
}
static void ParseViewsRecursive(ProjectItems items, ViewFolderInformation viewFolder)
{
    foreach (ProjectItem item in items)
    {
        if (item.Kind == EnvDTE.Constants.vsProjectItemKindPhysicalFile && Settings.ViewExtensions.Contains(Path.GetExtension(item.Name)))
        {
            viewFolder.Views.Add(new ViewInformation(item.Name));
        }
        else if (item.Kind == EnvDTE.Constants.vsProjectItemKindPhysicalFolder)
        {
            string folderName = Path.GetFileName(item.Name);
            if (folderName.Equals("App_LocalResources", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }
            var subViewFolder = new ViewFolderInformation() { Name = folderName };
            viewFolder.Folders.Add(subViewFolder);
            ParseViewsRecursive(item.ProjectItems, subViewFolder);
        }
    }
}
static Project GetProject(DTE dte, ITextTemplatingEngineHost host)
{
    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
    {
        projectItem.Open(EnvDTE.Constants.vsViewKindCode);
    }

    return projectItem.ContainingProject;
}
static ProjectItem GetProjectItem(Project project, string name)
{
    return GetProjectItem(project.ProjectItems, name);
}
static ProjectItem GetProjectItem(ProjectItems items, string subPath)
{
    ProjectItem current = null;
    foreach (string name in subPath.Split('\\'))
    {
        try
        {
            // ProjectItems.Item() throws when it doesn't exist, so catch the exception
            // to return null instead.
            current = items.Item(name);
        }
        catch
        {
            // If any chunk couldn't be found, fail
            return null;
        }
        items = current.ProjectItems;
    }
    return current;
}
static bool IsFolder(ProjectItem item)
{
    return (item.Kind == EnvDTE.Constants.vsProjectItemKindPhysicalFolder);
}
static bool IsController(CodeClass2 type)
{
	if (!type.FullName.EndsWith("Controller"))
	{
			return false;
	}

	for (; type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2)type.Bases.Item(1))
	{
		if (type.Bases.Count == 0)
		{
			return false;
		}
	}
	return true;
}
static bool IsAsyncController(CodeClass2 type)
{
    for (; type.FullName != "System.Web.Mvc.AsyncController"; type = (CodeClass2)type.Bases.Item(1))
    {
		if (type.Bases.Count == 0)
		{
			return false;
		}
    }
    return true;
}
static IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass, bool isAsyncController)
{
    return codeClass
		.Members
		.OfType<CodeFunction2>()
        .Where(f => 
			f.FunctionKind == vsCMFunction.vsCMFunctionFunction 
			&& f.Access == vsCMAccess.vsCMAccessPublic 
			&& f.IsGeneric == false 
			//&& f.Type.TypeKind != vsCMTypeRef.vsCMTypeRefCodeType //TODO
			//&& !(f.Type.CodeType is CodeClass2) 
			&& (isAsyncController && !f.Name.EndsWith("Completed", StringComparison.OrdinalIgnoreCase) || !isAsyncController) 
			&& !HasAnyAttribute(f.Attributes, "System.Web.Mvc.ObsoleteAttribute", "System.Web.Mvc.NonActionAttribute")
		);
}
static string GetAttributeValueOrDefault(CodeElements attributes, string attributeType, string defaultValue)
{
	var attribute = GetFirstAttribute(attributes, attributeType);
	return attribute == null ? 
		defaultValue : 
		((EnvDTE80.CodeAttributeArgument)attribute.Arguments.Item(1)).Value;
}
static bool HasAnyAttribute(CodeElements attributes, params string[] attributeTypes)
{
	return GetFirstAttribute(attributes, attributeTypes) != null;
}
static CodeAttribute2 GetFirstAttribute(CodeElements attributes, params string[] attributeTypes)
{
    for (int i = 1; i <= attributes.Count; i++)
    {
        try
        {
            var attribute = (CodeAttribute2)attributes.Item(i);
			foreach(string attributeType in attributeTypes)
            {
				if (attributeType.IndexOf(attribute.FullName, StringComparison.OrdinalIgnoreCase) != -1)
				{
					return attribute;
				}
            }
        }
        catch
        {
            // FullName can throw in some cases, so just ignore those attributes
            continue;
        }
    }
    return null;
}
static string GetRouteName(string areaName, string controllerName, string actionName)
{
	return areaName == null ? 
		string.Format("{0}.{1}", controllerName, actionName) :
		string.Format("{0}.{1}.{2}", areaName, controllerName, actionName); 
}
static string GetPathRelativeToTemplate(string path)
{
	return Path.Combine(TemplateFolderPath, path);
}
static string GetClassNameFromPathElement(string fileName)
{
	return GetIdentifier(Path.GetFileNameWithoutExtension(fileName));
}
static string GetControllerNamespaceFromType(CodeClass2 type)
{
	return Settings.GeneratedNamespace + "." + type.Namespace.Name;
}
static string GetControllerClassNameFromType(CodeClass2 type)
{
	return 	type.Name.EndsWith("Controller") ? 
		type.Name.Substring(0, type.Name.Length - "Controller".Length) : 
		type.Name;
}
static string GetIdentifier(string name)
{
	return CodeProvider.CreateEscapedIdentifier(
		CleanString(name));
}
static string GetIdentifier(string ns, string name)
{
    return string.IsNullOrEmpty(ns) ? 
		GetIdentifier(name) :
		ns + "." + GetIdentifier(name);
}
static string GetNamespace(params string [] parts)
{
	return parts.Aggregate((a, b) => a + "." + GetIdentifier(b));
}
static string CleanString(string s)
{
	StringBuilder sb = new StringBuilder(s.Length);
	for (int i = 0; i < s.Length; i++)
	{
		char c = s[i];
		switch (c)
		{
			case '\r':
			case '\n':
			case '\t':
			case ' ':
				continue;
			default:
				sb.Append(c);
				break;
		}
	}
	return sb.ToString();
}
static string GetFileName(string areaName, string name)
{
	return string.IsNullOrEmpty(areaName) ?
		name : 
		areaName + "." + name;
}
/* MODELS */
class MvcInformation
{
	public MvcInformation()
    {
		Areas = new List<AreaInformation>();
		PortableAreas = new List<AreaInformation>();
    }
	public AreaInformation DefaultArea { get; set; }
	public List<AreaInformation> Areas { get; private set; }
	public List<AreaInformation> PortableAreas { get; private set; }
}
class AreaInformation
{
	public AreaInformation()
    {
		ViewFolder = new ViewFolderInformation();
		Controllers = new List<ControllerInformation>();
    }
	public string Name { get; set; }
	public ViewFolderInformation ViewFolder { get; private set; }
	public List<ControllerInformation> Controllers { get; private set; }
}
class ViewFolderInformation
{
	public ViewFolderInformation()
    {
		Views = new List<ViewInformation>();
		Folders = new List<ViewFolderInformation>();
    }
	public string Name 
	{ 
		get
		{
			return _name;
		}
		set
		{
			ClassName = GetClassNameFromPathElement(value);
			_name = value;
		}
	}
	public string ClassName { get; private set; } 
	public List<ViewInformation> Views { get; private set; }
	public List<ViewFolderInformation> Folders { get; private set; }

	private string _name;
}
class ViewInformation
{
	public ViewInformation(string fileName)
    {
		this.FileName = fileName;
		this.ClassName = GetClassNameFromPathElement(fileName);
    }
	public string ClassName { get; private set; }
	public string FileName { get; private set; }
}
class ControllerInformation
{
	public ControllerInformation()
    {
		Actions = new List<ActionMethodInformation>();
    }
	public string Namespace { get; set; }
	public string ClassName { get; set; }
	public string FileName { get; set; }
	public string FilePath { get; set; }
	public bool NeedsGeneration { get; set; }
	public List<ActionMethodInformation> Actions { get; private set; }
}
class ActionMethodInformation
{
	public ActionMethodInformation()
    {
		Parameters = new List<ParameterInformation>();
    }
	public string Name { get; set; }
	public string RouteName { get; set; }
	public string ActionNameExpression { get; set; }
	public bool RequireHttps { get; set; }
	public bool CanBeCalledWithoutParameters { get; set; }
	public List<ParameterInformation> Parameters { get; private set; }
}
class ParameterInformation
{
    public string Name { get; set; }
    public string RouteNameExpression { get; set; }
    public string Type { get; set; }
    public string DefaultValue { get; set; }
	public bool Optional { get; set; }
}
#>